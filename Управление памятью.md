#### Выделение памяти в Си

Чтобы переменные можно было использовать с Си, сначала необходимо получить для них память от операционной системы. В Си существуют три механизма выделения памяти:
- _Статическое выделение памяти_. Требования к памяти вычисляются во время компиляции, а _память выделяется_ исполняемым файлом _при запуске_.
- _Автоматическое выделение памяти_. _Память_ для области видимости _выделяется из стека вызовов_ при входе в кадр и освобождается при завершении кадра.
- _Динамическое выделение памяти_. Память запрашивается и выделяется динамически во время выполнения через вызов API выделения памяти.

##### Статическое выделение памяти

Компилятор вычисляет требования к памяти для всех статических и глобальных переменных, а затем компилирует эти требования в приложение
```C
static int number = 0;
```

Массивы определяются статически. Возьмем массив из 10 целых чисел
```C
static int numbers[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
```

Компилятор Си преобразует эту команду в выделение `sizeof(int) * 10` байт памяти.

Компилятор Си использует системные функции для выделения памяти. Речь идет о системных сервисах, зависящих от операционной системы; это низкоуровневые функции ядра, выделяющие страницы системной памяти.

##### Автоматическое выделение памяти в Си

По аналогии со статическим выделением памяти, механизм автоматического выделения памяти вычисляет требования к памяти во время компиляции. 
```C
#include <stdio.h>

static const double five_ninths = 5.0 / 9.0;

double celsius(double fahrenheit) {
  double c = (fahrenheit - 32) * five_ninths;

  return c;
}

int main() {
  double f = 100;
  printf("%f F is %f C\n", f, celsius(f))

  return 0;
}
```

В этом примере используется как статитческое, так и динамическое выделение памяти:
- Память для константы `five_ninths` выделяется _статически_, потому что она объявлена с ключевым словом `static` (спецификатор хранения). 
- Память для переменной `c` функции `celsius()`  выделяется автоматически при вызове `celsius()` и освобождается при завершении `celsius()`.
- Память для переменной `f` в `main()` выделяется автоматически  при вызове `main()` и освобождается при завершении `main()`.
- Память для результата `celsius(f)` неявно выделяется автоматически.
- Память, автоматически выделяемая для `main()`, освобождается при завершении функции.

##### Динамическое выделение памяти в Си

Во многих случаях как статического, так и автоматического выделения памяти оказываться недостаточно. Например, в некоторых случаях программа не может вычислить требования к памяти во время компиляции, потому что они определяются пользовательским вводом.

В таких случаях память выделяется _динамически_. Операционные системы резервируют часть системной памяти для динамического выделения процессам. Эта часть памяти называется _кучей_ (heap).

В следующем примере память выделяется динамически для массива
```C
#include <stdio.h>
#include <stdlib.h>

static const double five_ninths = 5.0 / 9.0;

double celsius(double fahrenheit) {
  double c = (fahrenheit - 32) * five_ninths;

  return c;
}

int main(int argc, char** argv) {
  if (argc != 2)
    return -1;

  int number = atoi(argv[1]);
  double* c_values = (double*)calloc(number, sizeof(double));
  double* f_values = (double*)calloc(number, sizeof(double));

  for (int i = 0; i < number; i++) {
    printf("%f F is %f C\n", f_values[i], c_values[i]);
  }
  free(c_values);
  free(f_values);

  return 0;
}
```

##### Проектирование системы управления памятью Python

CPython был простроен на базе Си, поэтому приходится использовать ограничения статического, динамического и автоматического выделения памяти. Из-за некоторых особенностей проектирования языка Python эти ограничения создают еще больше проблем:
- Python - это язык с _динамической типизацией_, а потому размер переменных не может быть вычислен _во время компиляции_.
- Размеры большинства базовых типов Python определяются динамически. Тип `list` может иметь произвольный размер, `dict` может содержать любое число ключей, и даже `int` является динамическим. Пользователю никогда не приходится задавать размер этих типов.
- Имена в Python могут повторно использоваться для значений разных типовя
```python
>>> value = 1
>>> value = "Python"
>>> value = [10, 20, 30]
```

Чтобы преодолеть эти ограничения, CPython в значительной мере полагается на динамическое выделение памяти, но добавляет страховку для автоматизации ее освобождения, используя алгоритм сборки мусора и подсчета ссылок.

Вместо того чтобы заставлять Python-разработчика заниматься выделением памяти, память объектов в Python выделяется автоматически через один унифицированный API. Архитектура требует, чтобы вся стандартная библиотека CPython и базовые модули (написанные на Си) использовали этот API.

###### Области выделения памяти

CPython поддерживает три области динамического выделения памяти:
- Область сырой (raw) памяти - используется для выделения памяти из системной кучи и больших объемов памяти, а также если она выделяется не для объектов Python.
- Область объектной (object) памяти - используется для выделения памяти для всех объектов Python.
- Область PyMem - то же, что `PYMEM_DOMAIN_OBJ`. Этот тип существует для обеспечения совместимости со старым API.

Все эти типы реализуют один и тот же интерфейс функций
- `_Alloc(size_t size` выделяет память размером `bytes` и возвращает указатель.
- `_Calloc(size_t nelem, size_t elsize)` выделяет память для `nelem` элементов, каждый из которых имеет размер `elsize`, и возвращает указатель.
- `_Realloc(void* ptr, size_t new_size)` выделяет память размером `new_size`.
- `_Free(void* ptr)` освобождает память по указателю `ptr` и возвращает ее в кучу.

###### Аллокаторы

CPython использует два аллокатора:
- `malloc`: аллокатор операционной системы для выделения ==сырой памяти==.
- `pymalloc`:  аллокатор CPython для выделения ==объектной памяти== и `PyMem`.

###### Аллокаторы памяти CPython

Аллокатор памяти CPython работает поверх системного аллокатора и использует собственный алгоритм для этого. Алгоритм похож на использующийся в системе механизм, но он адаптирован для CPython:
- В большинстве запросов выделения памяти используется небольшой фиксированный размер: для `PyObject` 16 байт, для `PyASCIIObject` 42 байта, для `PyCompactUnicodeObject` 72 байта и для `PyLongObject` 32 байта.
- Аллокатор `pymalloc` выделяет блоки памяти размером не более 256 Кбайт. Все, что больше, передается для распределения системе.
- `pymalloc` использует GIL вместо системной проверки безопасности потока.

###### Блоки, пулы и арены

Наибольшая группа ячеек памяти называется _ареной_ (arena). CPython создает арены размером 256 Кбайт, чтобы они совпадали по размеру с системной страницей. Границы системной страницы - непрерывный участок памяти фиксированной длины.

Арены выделяются из системной кучи, а в системах, поддерживающих анонимное распределение памяти, используется функция `mmap()`. Распределение памяти помогает сократить уровень фрагментации кучи для арен. Внутри арены создаются _пулы_.

Все пулы имеют размер 4096 байт (4 Кбайт), так что арена всегда содержит 64 пула. Внутри пула память делится на _блоки_.

###### Преимущества подсчета ссылок в CPython

Подсчет ссылок в Cpython прост, работает быстро и эффективно. Наиболее серьезный недостаток заключается в том, что он должен учитывать эффект каждой операции (и тщательно выдерживать баланс производительности). У механизма подсчета ссылок также имеется серьезный недостаток: _циклические ссылки_.

Пример
```python
x = []
x.append(x)
del x
```

Счетчик ссылок для `x` остается равным 1, потому что `x` ссылается сам на себя. Для преодоления этих затруднений и устранения подобных утечек памяти в CPython существует второй механизм управления памятью, называемый _сборкой мусора_

Сборщик мусора CPython старается осовободить память, которая используется для несуществующих объектов. Он включен по умолчанию и работает в фоновом режиме. Сборка мусора выполняется периодически после заданного количества операций.

Каждый объект Python хранит количество ссылок на него. Когда счетчик достигает нуля, объект перестает существовать и память освобождается.

Многие объекты Python конейнерного типа -- списки, кортежи, словари, множества -- могут привести к появлению ==циклических ссылок==.

##### Неотслеживаемые объекты и изменяемость

Некоторые экземпляры контейнерного типа никогда не изменяются, поэтому API предоставляет механизм для ==отмены отслеживания==. Чем меньше объектов отслеживается сборщиком мусора, тем быстрее и эффективнее выполняется сборка мусора [[Литература#^e7aa31]]<с. 195> 

Отличным примером _неотслеживаемых объектов_ являются кортежи. Кортежи неизменяемы; после того как они были созданы, изменить их не удастся. Тем не менее кортежи могут содержать изменяемые типы, например списки и словари.

При запуске сборщика мусора каждый кортеж обращается к своему содержимому и проверяет, действительно ли в нем только неизменяемые (неотслеживаемые) элементы. Этот шаг выполняется в `_PyTuple_MaybeUntrack()`. Если кортеж определяет, что он содержит только неизменяемые типы (например, булевы или целочисленные значения), то он исключает себя из списка отслеживания сборщиком мусора вызовом `_PyObject_GC_UNTRACK()`. 

Вновь созданный пустой словарь не отслеживается сборщиком мусора, но при добавлении в него элемента, который является отслеживаемым объектом, словарь подает запрос на отслеживание.

Чтобы узнать, отслеживается ли тот или иной объект, используйте функцию `gc.is_tracked(obj)`.

Для каждого поколения сборщик мусора использует двусвязанный список типа `PyGC_HEAD`. Чтобы сборщику не выполнять поиск по всем контейнерным типам, те из них, которые являются целями для него, имеют дополнительный заголовок, который связывает их в двусвязный список.







